#!/usr/bin/env python3

# 1-based index in this program.

# This is meant to be a major improvement in features over the version described in the SomaticSeq paper published in Genome Biology. 
# Version 2

# Sample command:
# python3 SSeq_merged.vcf2tsv.py -myvcf BINA.snp.vcf -samN snp_positions.normal.noindel.vcf.gz -samT snp_positions.tumor.noindel.5bpflank.vcf.gz -haploN haplo_N/merged.noindel.vcf.gz -haploT haplo_T/merged.noindel.vcf.gz -sniper somaticsniper/variants.vcf -varscan varscan2/variants.snp.vcf -jsm jointsnvmix2/variants.vcf -vardict vardict/variants.snp.vcf.gz -muse muse/variants.vcf -nbam normal.indelrealigned.bam -tbam tumor.indelrealigned.bam -fai human_g1k_v37_decoy.fasta.fai -outfile SSeq2.snp.tsv

# Nothing from MuTect VCF is extracted because nothing from that file is useful here. 
# Input VCF or pileup files can be either text file or compressed .gz files. 

# For now, supports only tumor-normal workflows. Some metrics from individual VCF files generated by individual tools assume paired workflow. Future versions may be more flexible. 

# Improvement since the 2015 Genome Biology publication:
# 1) Supports MuSE
# 2) Supports pileup file input
# 3) Uses VarDict's MQ (mapping quality score) if MQ is not found in SAMtools or HaplotypeCaller (mostly for INDELs).
# 4) Allow +/- INDEL lengh for insertion and deletion
# 5) Uses pysam to extract information directly from BAM files, e.g., flanking indel, edit distance, discordance, etc.

# -- 10/10/2015

import sys, argparse, math, gzip, os
import regex as re
import genomic_file_handlers as genome
import pileup_reader as pileup


parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-myvcf',   '--vcf-file', type=str, help='My VCF', required=True, default=None)

parser.add_argument('-samN',    '--samtools-normal-vcf-file', type=str, help='Normal VCF File',    required=False, default=None)
parser.add_argument('-samT',    '--samtools-tumor-vcf-file',  type=str, help='Tumor VCF File',     required=False, default=None)
parser.add_argument('-haploN',  '--haplo-normal-vcf-file',    type=str, help='Normal VCF File',    required=False, default=None)
parser.add_argument('-haploT',  '--haplo-tumor-vcf-file',     type=str, help='Tumor VCF File',     required=False, default=None)
parser.add_argument('-plN',     '--samtools-normal-pileup',   type=str, help='Normal pileup File', required=False, default=None)
parser.add_argument('-plT',     '--samtools-tumor-pileup',    type=str, help='Tumor pileup File',  required=False, default=None)
parser.add_argument('-nbam',    '--normal-bam-file',          type=str, help='Normal BAM File',    required=False, default=None)
parser.add_argument('-tbam',    '--tumor-bam-file',           type=str, help='Tumor BAM File',     required=False, default=None)

parser.add_argument('-mutect',  '--mutect-vcf',        type=str, help='MuTect VCF.',       required=False, default=None)
parser.add_argument('-sniper',  '--somaticsniper-vcf', type=str, help='SomaticSniper VCF', required=False, default=None)
parser.add_argument('-varscan', '--varscan-vcf',       type=str, help='VarScan2 VCF',      required=False, default=None)
parser.add_argument('-jsm',     '--jsm-vcf',           type=str, help='JointSNVMix2 VCF',  required=False, default=None)
parser.add_argument('-vardict', '--vardict-vcf',       type=str, help='VarDict VCF',       required=False, default=None)
parser.add_argument('-muse',    '--muse-vcf',          type=str, help='MuSE VCF',          required=False, default=None)

parser.add_argument('-fai',     '--reference-fasta-fai',  type=str, help='Use the fasta.fai file to get the contigs',      required=False, default=None)
parser.add_argument('-dict',    '--reference-fasta-dict', type=str, help='Use the reference dict file to get the contigs', required=False, default=None)

parser.add_argument('-scale',   '--p-scale', type=str, help='phred, fraction, or none', required=False, default=None)

parser.add_argument('-outfile', '--output-tsv-file', type=str, help='Output TSV Name', required=False, default=os.sys.stdout)

args = parser.parse_args()


# Rename input:
myvcf     = args.vcf_file

samN      = args.samtools_normal_vcf_file if args.samtools_normal_vcf_file else os.devnull
samT      = args.samtools_tumor_vcf_file  if args.samtools_tumor_vcf_file  else os.devnull
haploN    = args.haplo_normal_vcf_file    if args.haplo_normal_vcf_file    else os.devnull
haploT    = args.haplo_tumor_vcf_file     if args.haplo_tumor_vcf_file     else os.devnull
plN       = args.samtools_normal_pileup   if args.samtools_normal_pileup   else os.devnull
plT       = args.samtools_tumor_pileup    if args.samtools_tumor_pileup    else os.devnull

mutectv   = args.mutect_vcf               if args.mutect_vcf               else os.devnull
sniperv   = args.somaticsniper_vcf        if args.somaticsniper_vcf        else os.devnull
varscanv  = args.varscan_vcf              if args.varscan_vcf              else os.devnull
jsmv      = args.jsm_vcf                  if args.jsm_vcf                  else os.devnull
vardictv  = args.vardict_vcf              if args.vardict_vcf              else os.devnull
musev     = args.muse_vcf                 if args.muse_vcf                 else os.devnull
nbam_fn   = args.normal_bam_file          if args.normal_bam_file          else os.devnull
tbam_fn   = args.tumor_bam_file           if args.tumor_bam_file           else os.devnull

fai_file  = args.reference_fasta_fai
dict_file = args.reference_fasta_dict
outfile   = args.output_tsv_file
p_scale   = args.p_scale

nan = float('nan')
inf = float('inf')

if args.normal_bam_file or args.tumor_bam_file:
	
    import pysam
    import scipy.stats as stats
    
    #nbam = pysam.AlignmentFile(nbam_fn, 'rb')  if args.normal_bam_file else os.devnull
    #tbam = pysam.AlignmentFile(tbam_fn,  'rb')  if args.tumor_bam_file else os.devnull

    # CIGAR string meaning:
    cigar_aln_match    = 0
    cigar_insertion    = 1
    cigar_deletion     = 2
    cigar_skip         = 3
    cigar_soft_clip    = 4
    cigar_hard_clip    = 5
    cigar_padding      = 6
    cigar_seq_match    = 7
    cigar_seq_mismatch = 8
    
    def position_of_aligned_read(read_i, target_position):
        '''
        Return the base call of the target position, or if it's a start of insertion/deletion.
        This target position follows pysam convension, i.e., 0-based. 
        In VCF files, deletions/insertions occur AFTER the position.
        
        Return (Code, seq_i, base_at_target, indel_length, nearest insertion/deletion)
        
        The first number in result is a code:
        1) Match to reference, which is either a reference read or a SNV/SNP
        2) Deletion after the target position
        3) Insertion after the target position
        0) The target position does not match to reference, and may be discarded for "reference/alternate" read count purposes, but can be kept for "inconsistent read" metrics. 
        '''
        
        flanking_deletion, flanking_insertion = nan, nan
        
        for i, align_i in enumerate(read_i.aligned_pairs):
            
            # If find a match:
            if align_i[1] == target_position:
                seq_i = align_i[0]
                break
        
        
        # If the target position is aligned:
        try:
            if isinstance(seq_i, int): 
                base_at_target = read_i.seq[seq_i]
                
                # Whether if it's a Deletion/Insertion depends on what happens after this position:
                # If the match (i.e., i, seq_i) is the final alignment, then you cannot know if it's an indel
                # if "i" is NOT the final alignment:
                if i != len(read_i.aligned_pairs) - 1:
                    
                    indel_length = 0
                    # If the next alignment is the next sequenced base, then the target is either a reference read of a SNP/SNV:
                    if read_i.aligned_pairs[i+1][0] == seq_i+1 and read_i.aligned_pairs[i+1][1] == target_position + 1:
                        
                        code = 1 # Reference read for mismatch
                    
                    # If the next reference position has no read position to it, it is DELETED in this read:
                    elif read_i.aligned_pairs[i+1][0] == None and read_i.aligned_pairs[i+1][1] == target_position + 1:
                        
                        code = 2 # Deletion
                        
                        for align_j in read_i.aligned_pairs[ i+1:: ]:
                            if align_j[0] == None:
                                indel_length -= 1
                            else:
                                break
                            
                    # Opposite of deletion, if the read position cannot be aligned to the reference, it can be an INSERTION.
                    # Insertions sometimes show up wit soft-clipping at the end, if the inserted sequence is "too long" to align on a single read. In this case, the inserted length derived here is but a lower limit of the real inserted length. 
                    elif read_i.aligned_pairs[i+1][0] == seq_i+1 and read_i.aligned_pairs[i+1][1] == None:
                        
                        code = 3 # Insertion or soft-clipping
                        
                        for align_j in read_i.aligned_pairs[ i+1:: ]:
                            if align_j[1] == None:
                                indel_length += 1
                            else:
                                break
                
                # If "i" is the final alignment, cannt exam for indel:
                else:
                    code = 1           # Assuming no indel
                    indel_length = nan # Would be zero if certain no indel, but uncertain here
            
            # If the target position is deleted from the sequencing read (i.e., the deletion in this read occurs before the target position):
            elif seq_i == None:
                code = 0
                base_at_target, indel_length, flanking_indel = None, None, None
            
            
            # See if there is insertion/deletion within 5 bp of "i":
            if isinstance(indel_length, int): 
                flanking_indel = inf
                left_side_start = seq_i
                right_side_start = seq_i + abs(indel_length) + 1
                switch = 1
                for j in (3,2,1):
                    for indel_seeker_i in left_side_start, right_side_start:
                        
                        switch = switch * -1
                        displacement = j * switch
                        seq_j = indel_seeker_i + displacement
                                        
                        if 0 <= seq_j < len(read_i.aligned_pairs):
                        
                            # If the reference position has no base aligned to it, it's a deletion.
                            # On the other hand, if the base has no reference base aligned to it, it's an insertion.
                            if read_i.aligned_pairs[ seq_j ][1] == None or read_i.aligned_pairs[ seq_j ][0] == None:
                                flanking_indel = j
                                break
            else:
                flanking_indel = None
                
            return code, seq_i, base_at_target, indel_length, flanking_indel
        
        # The target position does not exist in the read
        except UnboundLocalError:
            return None, None, None, None, None
    
    
    


if p_scale == None:
    print('NO RE-SCALING', file=sys.stderr)
elif p_scale.lower() == 'phred':
    p_scale = 'phred'
elif p_scale.lower() == 'fraction':
    p_scale = 'fraction'
else:
    print('NO RE-SCALING', file=sys.stderr)
    p_scale = None



# Convert contig_sequence to chrom_seq dict:
if dict_file:
    chrom_seq = genome.faiordict2contigorder(dict_file, 'dict')
elif fai_file:
    chrom_seq = genome.faiordict2contigorder(fai_file, 'fai')
else:
    raise Exception('I need a fai or dict file, or else I do not know the contig order.')


# Normal/Tumor index in the Merged VCF file, or any other VCF file that puts NORMAL first. 
idxN,idxT = 0,1

# Normal/Tumor index in VarDict VCF, or any other VCF file that puts TUMOR first.
vdT,vdN = 0,1

pattern_chr_position = genome.pattern_chr_position


## Define functions:
def rescale(x, original=None, rescale_to=p_scale, max_phred=1001):
    if ( rescale_to == None ) or ( original.lower() == rescale_to.lower() ):
        y = x if isinstance(x, int) else '%.2f' % x
    elif original.lower() == 'fraction' and rescale_to == 'phred':
        y = genome.p2phred(x, max_phred=max_phred)
        y = '%.2f' % y
    elif original.lower() == 'phred' and rescale_to == 'fraction':
        y = genome.phred2p(x)
        y = '%.2f' % y
    return y
    

def mean(stuff):
    try:
        return sum(stuff)/len(stuff)
        
    except ZeroDivisionError:
        return float('nan')


##### Extract Indel DP4 info from pileup files:
def pileup_indel_DP4(pileup_object, indel_pattern):
    if pileup_object.reads:
        ref_for = pileup_object.reads.count('.')
        ref_rev = pileup_object.reads.count(',')
        alt_for = pileup_object.reads.count( indel_pattern.upper() )
        alt_rev = pileup_object.reads.count( indel_pattern.lower() )
        
        dp4     = ref_for, ref_rev, alt_for, alt_rev
        
    else:
        dp4 = nan,nan,nan,nan

    return dp4



def pileup_DP4(pileup_object, ref_base, variant_call):
    
    base_calls = pileup_object.base_reads()
    
    if base_calls:
        
        # SNV
        if len(variant_call) == len(ref_base):
            
            ref_for,ref_rev,alt_for,alt_rev = base_calls[0], base_calls[1], base_calls[2].count(variant_call.upper()), base_calls[3].count(variant_call.lower())
        
        # Insertion:
        elif len(variant_call) > len(ref_base):
            
            inserted_sequence = variant_call[ len(ref_base):: ]
            
            ref_for,ref_rev,alt_for,alt_rev = base_calls[0], base_calls[1], base_calls[6].count(inserted_sequence.upper()), base_calls[7].count(inserted_sequence.lower())
        
        # Deletion:
        elif len(variant_call) < len(ref_base):
            
            deleted_sequence = ref_base[ len(variant_call):: ]
            
            ref_for,ref_rev,alt_for,alt_rev = base_calls[0], base_calls[1], base_calls[4].count(deleted_sequence.upper()), base_calls[5].count(deleted_sequence.lower())
    
    else:
        ref_for = ref_rev = alt_for = alt_rev = 0
    
    return ref_for, ref_rev, alt_for, alt_rev
    
    
    


##### Extract information from external vcf files:
##### From Samtools vcf:
def sam_info_DP4(vcf_object):
    dp4_string = vcf_object.get_info_value('DP4')
    if dp4_string:
        dp4_string = dp4_string.split(',')
        dp4 = ( int(dp4_string[0]), int(dp4_string[1]), int(dp4_string[2]), int(dp4_string[3]) )
    else:
        dp4 = nan,nan,nan,nan
        
    return dp4
    


def sam_info_DP(vcf_object):
    result = vcf_object.get_info_value('DP')
    if result:
        return eval(result)
    else:
        return nan
    


def sam_info_MQ(vcf_object):
    result = vcf_object.get_info_value('MQ')
    if result:
        return eval(result)
    else:
        return nan



def sam_info_PV4(vcf_object):
    '''P-values for strand bias, baseQ bias, mapQ bias and tail distance bias'''
    pv4_string = vcf_object.get_info_value('PV4')
    if pv4_string:
        pv4_string = pv4_string.split(',')
        pv4 = ( float(pv4_string[0]), float(pv4_string[1]), float(pv4_string[2]), float(pv4_string[3]) )
    else:
        pv4 = nan,nan,nan,nan
    
    return pv4
    


##### From Haplotype caller vcf:
def haplo_MQ0(vcf_object):
    '''Total Mapping Quality Zero Reads'''
    
    mq0 = vcf_object.get_info_value('MQ0')
    if mq0:
        mq0 = eval(mq0)
    else:
        mq0 = nan
        
    return mq0



def haplo_MQ(vcf_object):
    '''RMS Mapping Quality'''
    result = vcf_object.get_info_value('MQ')
    if result:
        return eval(result)
    else:
        return nan
    
    
    
def haplo_MLEAF(vcf_object):
    '''Maximum likelihood expectation (MLE) for the allele frequency (not necessarily the same as the AF), for each ALT allele, in the same order as listed'''
    
    mleaf = vcf_object.get_info_value('MLEAF')
    
    if mleaf:
        mleaf = mleaf.split(',')
        mleaf = [eval(i) for i in mleaf]
        mleaf = max(mleaf)
        
    else:
        mleaf = nan
        
    return mleaf
    
    
    
def haplo_MLEAC(vcf_object):
    '''Maximum likelihood expectation (MLE) for the allele counts (not necessarily the same as the AC), for each ALT allele, in the same order as listed'''
    
    mleac = vcf_object.get_info_value('MLEAC')
    
    if mleac:        
        mleac = mleac.split(',')
        mleac = [eval(i) for i in mleac]
        mleac = max(mleac)
        
    else:
        mleac = nan
        
    return mleac



def haplo_DP(vcf_object):
    result = vcf_object.get_sample_value('DP')
    if result:
        return eval(result)
    else:
        return nan


def haplo_BaseQRankSum(vcf_object):
    '''Z-score from Wilcoxon rank sum test of Alt Vs. Ref base qualities'''
    result = vcf_object.get_info_value('BaseQRankSum')
    return eval(result) if result else nan
    
    
def haplo_ClippingRankSum(vcf_object):
    '''Z-score From Wilcoxon rank sum test of Alt vs. Ref number of hard clipped bases'''
    result = vcf_object.get_info_value('ClippingRankSum')
    return eval(result) if result else nan
    
    
def haplo_LikelihoodRankSum(vcf_object):
    '''Z-score from Wilcoxon rank sum test of Alt Vs. Ref haplotype likelihoods'''
    result = vcf_object.get_info_value('LikelihoodRankSum')
    return eval(result) if result else nan
    
    
def haplo_ReadPosRankSum(vcf_object):
    '''Z-score from Wilcoxon rank sum test of Alt vs. Ref read position bias'''
    result = vcf_object.get_info_value('ReadPosRankSum')
    return eval(result) if result else nan
    
    
def haplo_MQRankSum(vcf_object):
    '''Z-score From Wilcoxon rank sum test of Alt vs. Ref read mapping qualities'''
    result = vcf_object.get_info_value('MQRankSum')
    return eval(result) if result else nan



##### Stuff from my own vcf:
def calculate_baf(caf_string):
    try:
        caf = re.search(r'\[[0-9.,]+\]', caf_string)
        if caf:
            caf_match = re.sub(r'\.([^0-9])', r'0\g<1>', caf.group())
            caf = list( eval(caf_match) )
            caf.sort()
            baf = sum(caf[0:-1])  # Minor Allele Frequency
            return baf
            
    except TypeError:
        return nan
        
    

  

def find_AMQ(vcf_object, i):
    amq = vcf_object.get_sample_value('AMQ', idx=i)
    
    if amq:
        amq = amq.split(',')
        amq_ref = eval(amq[0])
        try:
            amq_alt = eval(amq[1])
        except IndexError:
            amq_alt = nan
    
    else:
        amq_ref, amq_alt = nan, nan
        
    return amq_ref, amq_alt



def find_BQ(vcf_object, i):
    bq = vcf_object.get_sample_value('BQ', idx=i)
    # If there are two numbers, it came from SomaticSniper. If there is one number, it came from MuTect. 
    
    if bq:
        
        if bq == '.':
            bq_ref, bq_alt = nan, nan
            
        elif ',' in bq:
            bq = bq.split(',')
            bq_ref = eval(bq[0])
            bq_alt = eval(bq[1])
            
        else:
            bq_ref, bq_alt = eval(bq), eval(bq)
            
    else:
        bq_ref, bq_alt = nan, nan
        
    return bq_ref, bq_alt
    
    

def find_SOR(vcf_object):
    # VarDict's odd ratio, could be Inf, but other than Inf max was 180, so I will convert Inf --> 200. Stored in the TUMOR sample. 
    
    sor = vcf_object.get_info_value('SOR')
    if sor:
        sor = float(sor) if sor != 'Inf' else 200
    else:
        sor = nan
        
    return sor
    


def find_MSI(vcf_object):
    
    msi = vcf_object.get_info_value('MSI')
    if msi:
        msi = float(msi)
    else:
        msi = nan
    return msi
    
    
    
def find_MSILEN(vcf_object):
    
    msilen = vcf_object.get_info_value('MSILEN')
    if msilen:
        msilen = float(msilen)
    else:
        msilen = nan
    return msilen



def find_SHIFT3(vcf_object):
    
    shift3 = vcf_object.get_info_value('SHIFT3')
    if shift3:
        shift3 = float(shift3)
    else:
        shift3 = nan
    return shift3





# Header for the output data, created here so I won't have to indent this line:
out_header = \
'{CHROM}\t\
{POS}\t\
{ID}\t\
{REF}\t\
{ALT}\t\
{if_MuTect}\t\
{if_VarScan2}\t\
{if_JointSNVMix2}\t\
{if_SomaticSniper}\t\
{if_VarDict}\t\
{MuSE_Tier}\t\
{VarScan2_Score}\t\
{SNVMix2_Score}\t\
{Sniper_Score}\t\
{VarDict_Score}\t\
{if_dbsnp}\t\
{COMMON}\t\
{N_DP}\t\
{N_NM}\t\
{N_PMEAN}\t\
{N_QSTD}\t\
{N_PSTD}\t\
{N_VQUAL}\t\
{N_MLEAC}\t\
{N_MLEAF}\t\
{N_BaseQRankSum}\t\
{N_ClippingRankSum}\t\
{N_LikelihoodRankSum}\t\
{N_ReadPosRankSum}\t\
{N_MQRankSum}\t\
{nBAM_REF_MQ}\t\
{nBAM_ALT_MQ}\t\
{nBAM_Z_Ranksums_MQ}\t\
{nBAM_REF_BQ}\t\
{nBAM_ALT_BQ}\t\
{nBAM_Z_Ranksums_BQ}\t\
{nBAM_REF_NM}\t\
{nBAM_ALT_NM}\t\
{nBAM_REF_Concordant}\t\
{nBAM_REF_Discordant}\t\
{nBAM_ALT_Concordant}\t\
{nBAM_ALT_Discordant}\t\
{nBAM_Concordance_FET}\t\
{N_REF_FOR}\t\
{N_REF_REV}\t\
{N_ALT_FOR}\t\
{N_ALT_REV}\t\
{nBAM_StrandBias_FET}\t\
{nBAM_Z_Ranksums_EndPos}\t\
{nBAM_REF_Clipped_Reads}\t\
{nBAM_ALT_Clipped_Reads}\t\
{nBAM_Clipping_FET}\t\
{nBAM_REF_MQ0}\t\
{nBAM_ALT_MQ0}\t\
{nBAM_Other_Reads}\t\
{nBAM_REF_InDel_3bp}\t\
{nBAM_REF_InDel_2bp}\t\
{nBAM_REF_InDel_1bp}\t\
{nBAM_ALT_InDel_3bp}\t\
{nBAM_ALT_InDel_2bp}\t\
{nBAM_ALT_InDel_1bp}\t\
{SOR}\t\
{MSI}\t\
{MSILEN}\t\
{SHIFT3}\t\
{MaxHomopolymer_Length}\t\
{SiteHomopolymer_Length}\t\
{T_DP}\t\
{T_NM}\t\
{T_PMEAN}\t\
{T_QSTD}\t\
{T_PSTD}\t\
{T_VQUAL}\t\
{T_MLEAC}\t\
{T_MLEAF}\t\
{T_BaseQRankSum}\t\
{T_ClippingRankSum}\t\
{T_LikelihoodRankSum}\t\
{T_ReadPosRankSum}\t\
{T_MQRankSum}\t\
{tBAM_REF_MQ}\t\
{tBAM_ALT_MQ}\t\
{tBAM_Z_Ranksums_MQ}\t\
{tBAM_REF_BQ}\t\
{tBAM_ALT_BQ}\t\
{tBAM_Z_Ranksums_BQ}\t\
{tBAM_REF_NM}\t\
{tBAM_ALT_NM}\t\
{tBAM_REF_Concordant}\t\
{tBAM_REF_Discordant}\t\
{tBAM_ALT_Concordant}\t\
{tBAM_ALT_Discordant}\t\
{tBAM_Concordance_FET}\t\
{T_REF_FOR}\t\
{T_REF_REV}\t\
{T_ALT_FOR}\t\
{T_ALT_REV}\t\
{tBAM_StrandBias_FET}\t\
{tBAM_Z_Ranksums_EndPos}\t\
{tBAM_REF_Clipped_Reads}\t\
{tBAM_ALT_Clipped_Reads}\t\
{tBAM_Clipping_FET}\t\
{tBAM_REF_MQ0}\t\
{tBAM_ALT_MQ0}\t\
{tBAM_Other_Reads}\t\
{tBAM_REF_InDel_3bp}\t\
{tBAM_REF_InDel_2bp}\t\
{tBAM_REF_InDel_1bp}\t\
{tBAM_ALT_InDel_3bp}\t\
{tBAM_ALT_InDel_2bp}\t\
{tBAM_ALT_InDel_1bp}\t\
{InDel_Length}\t\
{TrueVariant_or_False}'




## Running
with genome.open_textfile(myvcf) as my_vcf, \
genome.open_textfile(samN)       as samN, \
genome.open_textfile(samT)       as samT, \
genome.open_textfile(plN)        as plN, \
genome.open_textfile(plT)        as plT, \
genome.open_textfile(haploN)     as haploN, \
genome.open_textfile(haploT)     as haploT, \
genome.open_textfile(mutectv)    as mutect, \
genome.open_textfile(sniperv)    as sniper, \
genome.open_textfile(varscanv)   as varscan, \
genome.open_textfile(jsmv)       as jsm, \
genome.open_textfile(vardictv)   as vardict, \
genome.open_textfile(musev)      as muse, \
genome.open_bam_file(nbam_fn)    as nbam, \
genome.open_bam_file(tbam_fn)    as tbam, \
open(outfile, 'w')               as outhandle:
    
    
    my_line      = my_vcf.readline().rstrip()
    nsam_line    = samN.readline().rstrip()
    tsam_line    = samT.readline().rstrip()
    npileup_line = plN.readline().rstrip()
    tpileup_line = plT.readline().rstrip()
    nhaplo_line  = haploN.readline().rstrip()
    thaplo_line  = haploT.readline().rstrip()
    mutect_line  = mutect.readline().rstrip()
    sniper_line  = sniper.readline().rstrip()
    varscan_line = varscan.readline().rstrip()
    jsm_line     = jsm.readline().rstrip()
    vardict_line = vardict.readline().rstrip()
    muse_line    = muse.readline().rstrip()
    
    
    # Get through all the headers:
    while my_line.startswith('#'):
        my_line = my_vcf.readline().rstrip()
    
    while nsam_line.startswith('#'):
        nsam_line = samN.readline().rstrip()

    while tsam_line.startswith('#'):
        tsam_line = samT.readline().rstrip()

    while nhaplo_line.startswith('#'):
        nhaplo_line = haploN.readline().rstrip()

    while thaplo_line.startswith('#'):
        thaplo_line = haploT.readline().rstrip()
        
    while mutect_line.startswith('#'):
        mutect_line = mutect.readline().rstrip()

    while sniper_line.startswith('#'):
        sniper_line = sniper.readline().rstrip()

    while varscan_line.startswith('#'):
        varscan_line = varscan.readline().rstrip()

    while jsm_line.startswith('#'):
        jsm_line = jsm.readline().rstrip()

    while vardict_line.startswith('#'):
        vardict_line = vardict.readline().rstrip()
        
    while muse_line.startswith('#'):
        muse_line = muse.readline().rstrip()
                    
    # First line:
    outhandle.write( out_header.replace('{','').replace('}','')  + '\n' )
    
    
    while my_line:
        
        my_coordinate = re.match( pattern_chr_position, my_line )
        if my_coordinate:
            my_coordinate = my_coordinate.group()
        else:
            print(my_line, file=sys.stderr)
            raise Exception('Coordinate does not match pattern.')
        
        ###################################################################################
        ############################ See what's in MY VCF line ############################
        my_vcfcall = genome.Vcf_line( my_line )
        
        # False Negatives are not a part of my original call:
        if 'FalseNegative' not in my_vcfcall.identifier:
            
            # If it's a "complex" variant (very rare), get me the first entry. 
            first_alt = my_vcfcall.altbase.split(',')[0]
            indel_length = len(first_alt) - len(my_vcfcall.refbase)
            
            ### Somatic Callers:
            caller_positives = my_vcfcall.get_info_value('SOURCES')
            
            if caller_positives:
                
                callers = caller_positives.split(',')
                
                cga_positive           = 1 if 'CGA'           in callers else 0
                varscan2_positive      = 1 if 'VarScan2'      in callers else 0
                jointsnvmix2_positive  = 1 if 'JointSNVMix2'  in callers else 0
                somaticsniper_positive = 1 if 'SomaticSniper' in callers else 0
                vardict_positive       = 1 if 'VarDict'       in callers else 0
            
            else:
                cga_positive,varscan2_positive,jointsnvmix2_positive,somaticsniper_positive,vardict_positive = 0,0,0,0,0
                
                
            ### Calculate minor allele frequency (B Allele Frequency) in dbSNP data:
            caf = my_vcfcall.get_info_value('CAF')
            if caf:
                baf = calculate_baf(caf)
            else:
                baf = nan
                
                
            ### Is it in dbSNP:
            if re.search('rs[0-9]+', my_vcfcall.identifier):
                in_dbsnp = 1
            else:
                in_dbsnp = 0
                
            # Common SNP score:
            score_common_snp = 1 if my_vcfcall.get_info_value('COMMON') == '1' else 0
            g5 = 1 if my_vcfcall.get_info_value('G5') else 0
            g5a = 1 if my_vcfcall.get_info_value('G5A') else 0
            
    
            #####     #####     #####     #####     #####     #####
            if 'Correct' in my_vcfcall.identifier:
                judgement = 1
            elif 'FalsePositive' in my_vcfcall.identifier:
                judgement = 0
            else:
                judgement = nan
            #####     #####     #####     #####     #####     #####
            
            

            ############################################################################################
            ########## ######### ######### INFO EXTRACTION FROM BAM FILES ########## ######### #########
            # Normal BAM file:
            if args.normal_bam_file:
                n_reads = nbam.fetch( my_vcfcall.chromosome, my_vcfcall.position-1, my_vcfcall.position )

                n_ref_read_mq = []
                n_alt_read_mq = []
                
                n_ref_read_bq = []
                n_alt_read_bq = []
                
                n_ref_edit_distance = []
                n_alt_edit_distance = []
                
                n_ref_concordant_reads = 0
                n_alt_concordant_reads = 0
                n_ref_discordant_reads = 0
                n_alt_discordant_reads = 0
                
                n_ref_for = 0
                n_ref_rev = 0
                n_alt_for = 0
                n_alt_rev = 0
                N_dp      = 0
                
                n_ref_SC_reads    = 0
                n_alt_SC_reads    = 0
                n_ref_notSC_reads = 0
                n_alt_notSC_reads = 0
                
                
                n_ref_MQ0 = 0
                n_alt_MQ0 = 0
                
                n_ref_pos_from_end = []
                n_alt_pos_from_end = []
                
                n_ref_flanking_indel = []
                n_alt_flanking_indel = []
                
                n_noise_read_count = 0
                
                for read_i in n_reads:
                    if not read_i.is_unmapped:
                        
                        N_dp += 1
                        
                        code_i, ith_base, base_call_i, indel_length_i, flanking_indel_i = position_of_aligned_read(read_i, my_vcfcall.position-1 )
                        
                        # Reference calls:
                        if code_i == 1 and base_call_i == my_vcfcall.refbase[0]:
                        
                            n_ref_read_mq.append( read_i.mapping_quality )
                            n_ref_read_bq.append( read_i.query_qualities[ith_base] )
                            n_ref_edit_distance.append( read_i.get_tag('NM') )
                            
                            # Concordance
                            if read_i.is_proper_pair:
                                n_ref_concordant_reads += 1
                            else:
                                n_ref_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= 1:
                                n_ref_for += 1
                            elif read_i.is_reverse and read_i.mapping_quality >= 1:
                                n_ref_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                n_ref_SC_reads += 1
                            else:
                                n_ref_notSC_reads += 1
                                
                            if read_i.mapping_quality == 0:
                                n_ref_MQ0 += 1
                                
                            # Distance from the end of the read:
                            if ith_base != None:
                                n_ref_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                
                            # Flanking indels:
                            n_ref_flanking_indel.append( flanking_indel_i )

                        
                        # Alternate calls:
                        # SNV, or Deletion, or Insertion where I do not check for matching indel length
                        elif (indel_length == 0 and code_i == 1 and base_call_i == first_alt) or \
                             (indel_length < 0  and code_i == 2 and indel_length == indel_length_i) or \
                             (indel_length > 0  and code_i == 3):
                            
                            n_alt_read_mq.append( read_i.mapping_quality )
                            n_alt_read_bq.append( read_i.query_qualities[ith_base] )
                            n_alt_edit_distance.append( read_i.get_tag('NM') )
                            
                            # Concordance
                            if read_i.is_proper_pair:
                                n_alt_concordant_reads += 1
                            else:
                                n_alt_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= 1:
                                n_alt_for += 1
                            elif read_i.is_reverse and read_i.mapping_quality >= 1:
                                n_alt_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                n_alt_SC_reads += 1
                            else:
                                n_alt_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                n_alt_MQ0 += 1

                            # Distance from the end of the read:
                            if ith_base != None:
                                n_alt_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                                    
                            # Flanking indels:
                            n_alt_flanking_indel.append( flanking_indel_i )
                        
                        
                        # Inconsistent read or 2nd alternate calls:
                        else:
                            n_noise_read_count += 1
                                
                        
                # Done extracting info from tumor BAM. Now tally them:
                n_ref_mq        = mean(n_ref_read_mq)
                n_alt_mq        = mean(n_alt_read_mq)
                n_z_ranksums_mq = stats.ranksums(n_alt_read_mq, n_ref_read_mq)[0]
                
                n_ref_bq        = mean(n_ref_read_bq)
                n_alt_bq        = mean(n_alt_read_bq)
                n_z_ranksums_bq = stats.ranksums(n_alt_read_bq, n_ref_read_bq)[0]
                
                n_ref_NM        = mean(n_ref_edit_distance)
                n_alt_NM        = mean(n_alt_edit_distance)
                n_z_ranksums_NM = stats.ranksums(n_alt_edit_distance, n_ref_edit_distance)[0]
                
                n_concordance_fet = stats.fisher_exact(( (n_ref_concordant_reads, n_alt_concordant_reads), (n_ref_discordant_reads, n_alt_discordant_reads) ))[1]
                n_strandbias_fet  = stats.fisher_exact(( (n_ref_for, n_alt_for), (n_ref_rev, n_alt_rev) ))[1]
                n_clipping_fet    = stats.fisher_exact(( (n_ref_notSC_reads, n_alt_notSC_reads), (n_ref_SC_reads, n_alt_SC_reads) ))[1]
                
                n_z_ranksums_endpos = stats.ranksums(n_alt_pos_from_end, n_ref_pos_from_end)[0]
                
                n_ref_indel_3bp = n_ref_flanking_indel.count(3)
                n_ref_indel_2bp = n_ref_flanking_indel.count(2)
                n_ref_indel_1bp = n_ref_flanking_indel.count(1)
                n_alt_indel_3bp = n_alt_flanking_indel.count(3)
                n_alt_indel_2bp = n_alt_flanking_indel.count(2)
                n_alt_indel_1bp = n_alt_flanking_indel.count(1)

            # If no normal BAM
            else:
                n_ref_mq = n_alt_mq = n_z_ranksums_mq = n_ref_bq = n_alt_bq = n_z_ranksums_bq = n_ref_NM = n_alt_NM = n_z_ranksums_NM = n_concordance_fet = n_strandbias_fet = n_z_ranksums_endpos = n_ref_indel_3bp = n_ref_indel_2bp = n_ref_indel_1bp = n_alt_indel_3bp = n_alt_indel_2bp = n_alt_indel_1bp = n_ref_SC_reads = n_alt_SC_reads = n_ref_notSC_reads = n_alt_notSC_reads = n_clipping_fet = n_noise_read_count = N_dp = nan
            
            
            # Tumor BAM file:
            if args.tumor_bam_file:
                t_reads = tbam.fetch( my_vcfcall.chromosome, my_vcfcall.position-1, my_vcfcall.position )
                
                t_ref_read_mq = []
                t_alt_read_mq = []
                
                t_ref_read_bq = []
                t_alt_read_bq = []
                
                t_ref_edit_distance = []
                t_alt_edit_distance = []
                
                t_ref_concordant_reads = 0
                t_alt_concordant_reads = 0
                t_ref_discordant_reads = 0
                t_alt_discordant_reads = 0
                
                t_ref_for = 0
                t_ref_rev = 0
                t_alt_for = 0
                t_alt_rev = 0
                T_dp      = 0
                
                t_ref_SC_reads    = 0
                t_alt_SC_reads    = 0
                t_ref_notSC_reads = 0
                t_alt_notSC_reads = 0

                t_ref_MQ0 = 0
                t_alt_MQ0 = 0
                
                t_ref_pos_from_end = []
                t_alt_pos_from_end = []
                
                t_ref_flanking_indel = []
                t_alt_flanking_indel = []
                
                t_noise_read_count = 0
                
                for read_i in t_reads:
                    if not read_i.is_unmapped:
                        
                        T_dp += 1
                        
                        code_i, ith_base, base_call_i, indel_length_i, flanking_indel_i = position_of_aligned_read(read_i, my_vcfcall.position-1 )
                        
                        # Reference calls:
                        if code_i == 1 and base_call_i == my_vcfcall.refbase[0]:
                        
                            t_ref_read_mq.append( read_i.mapping_quality )
                            t_ref_read_bq.append( read_i.query_qualities[ith_base] )
                            t_ref_edit_distance.append( read_i.get_tag('NM') )
                            
                            # Concordance
                            if read_i.is_proper_pair:
                                t_ref_concordant_reads += 1
                            else:
                                t_ref_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= 1:
                                t_ref_for += 1
                            elif read_i.is_reverse and read_i.mapping_quality >= 1:
                                t_ref_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                t_ref_SC_reads += 1
                            else:
                                t_ref_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                t_ref_MQ0 += 1
                                
                            # Distance from the end of the read:
                            if ith_base != None:
                                t_ref_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                
                            # Flanking indels:
                            t_ref_flanking_indel.append( flanking_indel_i )

                        
                        # Alternate calls:
                        # SNV, or Deletion, or Insertion where I do not check for matching indel length
                        elif (indel_length == 0 and code_i == 1 and base_call_i == first_alt) or \
                             (indel_length < 0  and code_i == 2 and indel_length == indel_length_i) or \
                             (indel_length > 0  and code_i == 3):
                            
                            t_alt_read_mq.append( read_i.mapping_quality )
                            t_alt_read_bq.append( read_i.query_qualities[ith_base] )
                            t_alt_edit_distance.append( read_i.get_tag('NM') )
                            
                            # Concordance
                            if read_i.is_proper_pair:
                                t_alt_concordant_reads += 1
                            else:
                                t_alt_discordant_reads += 1
                            
                            # Orientation
                            if (not read_i.is_reverse) and read_i.mapping_quality >= 1:
                                t_alt_for += 1
                            elif read_i.is_reverse and read_i.mapping_quality >= 1:
                                t_alt_rev += 1
                            
                            # Soft-clipped reads?
                            if read_i.cigar[0][0] == cigar_soft_clip or read_i.cigar[-1][0] == cigar_soft_clip:
                                t_alt_SC_reads += 1
                            else:
                                t_alt_notSC_reads += 1

                            if read_i.mapping_quality == 0:
                                t_alt_MQ0 += 1

                            # Distance from the end of the read:
                            if ith_base != None:
                                t_alt_pos_from_end.append( min(ith_base, read_i.query_length-ith_base) )
                                                    
                            # Flanking indels:
                            t_alt_flanking_indel.append( flanking_indel_i )
                        
                        
                        # Inconsistent read or 2nd alternate calls:
                        else:
                            t_noise_read_count += 1
                                
                        
                # Done extracting info from tumor BAM. Now tally them:
                t_ref_mq        = mean(t_ref_read_mq)
                t_alt_mq        = mean(t_alt_read_mq)
                t_z_ranksums_mq = stats.ranksums(t_alt_read_mq, t_ref_read_mq)[0]
                
                t_ref_bq        = mean(t_ref_read_bq)
                t_alt_bq        = mean(t_alt_read_bq)
                t_z_ranksums_bq = stats.ranksums(t_alt_read_bq, t_ref_read_bq)[0]
                
                t_ref_NM        = mean(t_ref_edit_distance)
                t_alt_NM        = mean(t_alt_edit_distance)
                t_z_ranksums_NM = stats.ranksums(t_alt_edit_distance, t_ref_edit_distance)[0]
                
                t_concordance_fet = stats.fisher_exact(( (t_ref_concordant_reads, t_alt_concordant_reads), (t_ref_discordant_reads, t_alt_discordant_reads) ))[1]
                t_strandbias_fet  = stats.fisher_exact(( (t_ref_for, t_alt_for), (t_ref_rev, t_alt_rev) ))[1]
                t_clipping_fet    = stats.fisher_exact(( (t_ref_notSC_reads, t_alt_notSC_reads), (t_ref_SC_reads, t_alt_SC_reads) ))[1]
                
                t_z_ranksums_endpos = stats.ranksums(t_alt_pos_from_end, t_ref_pos_from_end)[0]
                
                t_ref_indel_3bp = t_ref_flanking_indel.count(3)
                t_ref_indel_2bp = t_ref_flanking_indel.count(2)
                t_ref_indel_1bp = t_ref_flanking_indel.count(1)
                t_alt_indel_3bp = t_alt_flanking_indel.count(3)
                t_alt_indel_2bp = t_alt_flanking_indel.count(2)
                t_alt_indel_1bp = t_alt_flanking_indel.count(1)

            # If no tumor BAM
            else:
                t_ref_mq = t_alt_mq = t_z_ranksums_mq = t_ref_bq = t_alt_bq = t_z_ranksums_bq = t_ref_NM = t_alt_NM = t_z_ranksums_NM = t_concordance_fet = t_strandbias_fet = t_z_ranksums_endpos = t_ref_indel_3bp = t_ref_indel_2bp = t_ref_indel_1bp = t_alt_indel_3bp = t_alt_indel_2bp = t_alt_indel_1bp = t_ref_SC_reads = t_alt_SC_reads = t_ref_notSC_reads = t_alt_notSC_reads = t_clipping_fet = t_noise_read_count = T_dp = nan

            ############################################################################################
            ############################################################################################



            
            ############################################################################################
            ##################### Find the same coordinate in VarDict's VCF Output #####################
            if args.vardict_vcf:
                latest_vardict_run = genome.catchup(my_coordinate, vardict_line, vardict, chrom_seq)
                latest_vardict = genome.Vcf_line(latest_vardict_run[1])
                
                if latest_vardict_run[0]:
                    assert my_vcfcall.position == latest_vardict.position
                    
                    # Somatic Score:
                    if vardict_positive or ('Somatic' in latest_vardict.info):
                        score_vardict = latest_vardict.get_info_value('SSF')
                        score_vardict = float(score_vardict)
                        score_vardict = genome.p2phred(score_vardict, max_phred=100)
                    else:
                        score_vardict = nan


                    # SOR, MSI, MSILEN, and SHIFT3:
                    sor    = find_SOR(latest_vardict)
                    msi    = find_MSI(latest_vardict)
                    msilen = find_MSILEN(latest_vardict)
                    shift3 = find_SHIFT3(latest_vardict)

                    # Figure out the longest homopolymer length within the 41-bp region (20bp flank):
                    lseq = latest_vardict.get_info_value('LSEQ')
                    if lseq:
                        
                        # Longest homopolymer:
                        rseq = latest_vardict.get_info_value('RSEQ')
                        seq41_ref = lseq + latest_vardict.refbase + rseq
                        seq41_alt = lseq + first_alt + rseq
                        
                        ref_counts = genome.count_repeating_bases(seq41_ref)
                        alt_counts = genome.count_repeating_bases(seq41_alt)
                        
                        homopolymer_length = max( max(ref_counts), max(alt_counts) )
                        
                        # Homopolymer spanning the variant site:
                        site_homopolymer_left = re.search(r'[{}{}]+$'.format(latest_vardict.refbase, first_alt[0]), lseq)
                        if site_homopolymer_left:
                            site_homopolymer_left = site_homopolymer_left.group()
                        else:
                            site_homopolymer_left = ''
                        
                        site_homopolymer_right = re.match(r'{}+'.format(latest_vardict.refbase, first_alt[-1]), rseq)
                        if site_homopolymer_right:
                            site_homopolymer_right = site_homopolymer_right.group()
                        else:
                            site_homopolymer_right = ''
                        
                        site_homopolymer_ref = site_homopolymer_left + latest_vardict.refbase + site_homopolymer_right
                        site_homopolymer_alt = site_homopolymer_left + first_alt + site_homopolymer_right
                        
                        site_count_ref = genome.count_repeating_bases(site_homopolymer_ref)
                        site_count_alt = genome.count_repeating_bases(site_homopolymer_alt)
                        
                        site_homopolymer_length = max( max(site_count_ref), max(site_count_alt) )
                        
                            
                    else:
                        homopolymer_length      = nan
                        site_homopolymer_length = nan
            
                    
                    # Indel length. Yes, indel_length was extracted before, so this could potentially override that because this takes VarDict's assessment. 
                    indel_length = len(first_alt) - len(latest_vardict.refbase)
                    
                    ## VarDict's sample info:
                    # Mean mismatch:
                    n_nm = latest_vardict.get_sample_value('NM', vdN)
                    try:
                        n_nm = eval(n_nm)
                    except TypeError:
                        n_nm = nan
                        
                    t_nm = latest_vardict.get_sample_value('NM', vdT)
                    try:
                        t_nm = eval(t_nm)
                    except TypeError:
                        t_nm = nan
                        
                    # Mean position in reads:
                    n_pmean = latest_vardict.get_sample_value('PMEAN', vdN)
                    try:
                        n_pmean = eval( n_pmean )
                    except TypeError:
                        n_pmean = nan
                        
                    t_pmean = latest_vardict.get_sample_value('PMEAN', vdT)
                    try:
                        t_pmean = eval( t_pmean )
                    except TypeError:
                        t_pmean = nan
                        
                    # Read Position STD
                    n_pstd = latest_vardict.get_sample_value('PSTD', vdN)
                    try:
                        n_pstd = eval(n_pstd)
                    except TypeError:
                        n_pstd = nan
                        
                    t_pstd = latest_vardict.get_sample_value('PSTD', vdT)
                    try:
                        t_pstd = eval( t_pstd )
                    except TypeError:
                        t_pstd = nan
                        
                    # Quality score STD in reads:
                    n_qstd = latest_vardict.get_sample_value('QSTD', vdN)
                    try:
                        n_qstd = eval( n_qstd )
                    except TypeError:
                        n_qstd = nan
                        
                    t_qstd = latest_vardict.get_sample_value('QSTD', vdT)
                    try:
                        t_qstd = eval( t_qstd )
                    except TypeError:
                        t_qstd = nan
                    
                    # Quality Score
                    n_vqual = latest_vardict.get_sample_value('QUAL', vdN)
                    try:
                        n_vqual = eval( n_vqual )
                    except TypeError:
                        n_vqual = nan
                        
                    t_vqual = latest_vardict.get_sample_value('QUAL', vdT)
                    try:
                        t_vqual = eval( t_vqual )
                    except TypeError:
                        t_vqual = nan
        
        
                    # Mapping Score
                    N_mq_vd = latest_vardict.get_sample_value('MQ', vdN)
                    try:
                        N_mq_vd = eval( N_mq_vd )
                    except TypeError:
                        N_mq_vd = nan
                        
                    T_mq_vd = latest_vardict.get_sample_value('MQ', vdT)
                    try:
                        T_mq_vd = eval( T_mq_vd )
                    except TypeError:
                        T_mq_vd = nan
        

        
                    # Reset the current line:
                    vardict_line = latest_vardict.vcf_line

            
            
                # The VarDict.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    sor = msi = msilen = shift3 = homopolymer_length = site_homopolymer_length = n_nm = t_nm = n_pmean = t_pmean = n_pstd = t_pstd = n_qstd = t_qstd = n_vqual = t_vqual = N_mq_vd = T_mq_vd = score_vardict = nan
                    vardict_line = latest_vardict.vcf_line
                    
            else:
                
                sor = msi = msilen = shift3 = homopolymer_length = site_homopolymer_length = n_nm = t_nm = n_pmean = t_pmean = n_pstd = t_pstd = n_qstd = t_qstd = n_vqual = t_vqual = N_mq_vd = T_mq_vd = score_vardict = nan
            
            
            
            ############################################################################################
            ##################### Find the same coordinate in SomaticSniper's VCF# #####################
            # SomaticSniper's SSC may be wiped out during CombineVariants, since I made VarDict take precedence. Use the extra sniper file if available:
            if args.somaticsniper_vcf:
                
                latest_sniper_run = genome.catchup(my_coordinate, sniper_line, sniper, chrom_seq)
                latest_sniper = genome.Vcf_line(latest_sniper_run[1])
                
                if latest_sniper_run[0]:
                    
                    assert my_vcfcall.position == latest_sniper.position
                    
                    # Somatic Score:
                    if somaticsniper_positive:
                        score_somaticsniper = latest_sniper.get_sample_value('SSC', 1)
                        score_somaticsniper = int(score_somaticsniper) if score_somaticsniper else nan
                    else:
                        score_somaticsniper = nan
                        
                    # Variant Allele Quality:
                    n_vaq = latest_sniper.get_sample_value('VAQ', idxN)
                    n_vaq = int(n_vaq) if n_vaq else nan
                    
                    t_vaq = latest_sniper.get_sample_value('VAQ', idxT)
                    t_vaq = int(t_vaq) if t_vaq else nan
                    
                    # Average base quality:
                    n_bq_ref, n_bq_alt = find_BQ(latest_sniper, idxN)
                    t_bq_ref, t_bq_alt = find_BQ(latest_sniper, idxT)
            
                    # Average mapping quality for each allele present in the genotype:
                    n_amq_ref, n_amq_alt = find_AMQ(latest_sniper, idxN)
                    t_amq_ref, t_amq_alt = find_AMQ(latest_sniper, idxT)
                    
                    # Reset the current line:
                    sniper_line = latest_sniper.vcf_line

                
                # The SomaticSniper.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    n_vaq = t_vaq = n_amq_ref = n_amq_alt = t_amq_ref = t_amq_alt = n_bq_ref = n_bq_alt = t_bq_ref = t_bq_alt = score_somaticsniper = nan
                    sniper_line = latest_sniper.vcf_line
                    
            else:
                
                n_vaq = t_vaq = n_amq_ref = n_amq_alt = t_amq_ref = t_amq_alt = n_bq_ref = n_bq_alt = t_bq_ref = t_bq_alt = score_somaticsniper = nan
            
            
            
            ############################################################################################
            ######################## Find the same coordinate in VarScan's VCF #########################
            if args.varscan_vcf:
                
                latest_varscan_run = genome.catchup(my_coordinate, varscan_line, varscan, chrom_seq)
                latest_varscan = genome.Vcf_line(latest_varscan_run[1])
                
                if latest_varscan_run[0]:
                    
                    assert my_vcfcall.position == latest_varscan.position
                    
                    # Somatic Score:
                    score_varscan2 = int(latest_varscan.get_info_value('SSC'))
                    
                    # Reset the current line:
                    varscan_line = latest_varscan.vcf_line

                
                # The VarScan.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    score_varscan2 = nan
                    varscan_line = latest_varscan.vcf_line
                    
            else:
                
                score_varscan2 = nan
            
            
            ############################################################################################
            ########################## Find the same coordinate in JSM's VCF# ##########################
            if args.jsm_vcf:
                
                latest_jsm_run = genome.catchup(my_coordinate, jsm_line, jsm, chrom_seq)
                latest_jsm = genome.Vcf_line(latest_jsm_run[1])
                
                if latest_jsm_run[0]:
                    
                    assert my_vcfcall.position == latest_jsm.position
                    
                    # Somatic Score:
                    aaab = float( latest_jsm.get_info_value('AAAB') )
                    aabb = float( latest_jsm.get_info_value('AABB') )
                    jointsnvmix2_p = 1 - aaab - aabb
                    score_jointsnvmix2 = genome.p2phred(jointsnvmix2_p, max_phred=50)
                    
                    # Reset the current line:
                    jsm_line = latest_jsm.vcf_line

                # The VarScan.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    score_jointsnvmix2 = nan
                    jsm_line = latest_jsm.vcf_line
                    
            else:
                
                score_jointsnvmix2 = nan
            
            
            
            
            
            ############################################################################################
            ########################## Find the same coordinate in MuSE's VCF# #########################
            if args.muse_vcf:
                
                latest_muse_run = genome.catchup(my_coordinate, muse_line, muse, chrom_seq)
                latest_muse = genome.Vcf_line(latest_muse_run[1])
                
                if latest_muse_run[0]:
                    
                    assert my_vcfcall.position == latest_muse.position
                    
                    # PASS and Tiers:
                    if latest_muse.filters   == 'PASS':
                        muse_tier = 6
                    elif latest_muse.filters == 'Tier1':
                        muse_tier = 5                        
                    elif latest_muse.filters == 'Tier2':
                        muse_tier = 4
                    elif latest_muse.filters == 'Tier3':
                        muse_tier = 3
                    elif latest_muse.filters == 'Tier4':
                        muse_tier = 2
                    elif latest_muse.filters == 'Tier5':
                        muse_tier = 1
                    else:
                        muse_tier = 0
                    
                    # Reset the current line:
                    muse_line = latest_muse.vcf_line

                # The VarScan.vcf doesn't have this record, which doesn't make sense. It means wrong file supplied. 
                else:
                    muse_tier = 0
                    muse_line = latest_muse.vcf_line
                    
            else:
                
                muse_tier = 0
            
            
            
            
            ############################################################################################
            #################### Find the same coordinate in NORMAL vcf by SAMTOOLS ####################
            # Things to extract (if available): 
            # DP4, PV4 (strand bias, baseQ bias, mapQ bias, and tail distance bias), DP, and MQ
            if args.samtools_normal_vcf_file:
                
                latest_nsam_run = genome.catchup(my_coordinate, nsam_line, samN, chrom_seq)
                latest_samnormal = genome.Vcf_line(latest_nsam_run[1])
                
                # If the position exists in this samtools generated vcf file:
                if latest_nsam_run[0]:
                    
                    assert my_vcfcall.position == latest_samnormal.position
                    
                    # Normal samtools info extraction:
                    N_ref_for,N_ref_rev,N_alt_for,N_alt_rev = sam_info_DP4(latest_samnormal)
                    
                    #N_p_strandbias,N_p_baseQbias,N_p_mapQbias,N_p_taildisbias = sam_info_PV4(latest_samnormal)
                    
                    #try:
                        #N_Sdp = eval( latest_samnormal.get_info_value('DP') )
                    #except TypeError:
                        #N_Sdp = nan
                    
                    #N_mq  = sam_info_MQ(latest_samnormal)
                                    
                    # Reset the current line:
                    nsam_line = latest_samnormal.vcf_line
                    
                # If the position does not exist in this vcf file, in which case the sam_vcf should have gone past the my_coordinate:
                else:
                    
                    #assert genome.whoisbehind([my_vcfcall.chromosome, my_vcfcall.position], [latest_samnormal.chromosome, latest_samnormal.position]) == 0
                    nsam_line = latest_samnormal.vcf_line
                    
                    N_ref_for = N_ref_rev = N_alt_for = N_alt_rev = N_p_strandbias = N_p_baseQbias = N_p_mapQbias = N_p_taildisbias = N_Sdp = N_mq = nan
                    
            else:
                N_ref_for = N_ref_rev = N_alt_for = N_alt_rev = N_p_strandbias = N_p_baseQbias = N_p_mapQbias = N_p_taildisbias = N_Sdp = N_mq = nan
            
            
            #################### Find the same coordinate in NORMAL vcf by GATK Haplotype ####################
            # Things to extract (if available): 
            # DP, MQ, MQ0, MLEAC, MLEAF, BaseQRankSum, ClippingRankSum, LikelihoodRankSum, ReadPosRankSum, MQRankSum
            if args.haplo_normal_vcf_file:
                
                latest_nhaplo_run = genome.catchup(my_coordinate, nhaplo_line, haploN, chrom_seq)
                latest_haplonormal = genome.Vcf_line(latest_nhaplo_run[1])
                
                if latest_nhaplo_run[0]:
                    assert my_vcfcall.position == latest_haplonormal.position
                                    
                    # Normal haplotype caller info extraction:
                    N_mq0         = haplo_MQ0(latest_haplonormal)
                    N_mleac       = haplo_MLEAC(latest_haplonormal)
                    N_mleaf       = haplo_MLEAF(latest_haplonormal)
                    N_baseQrank   = haplo_BaseQRankSum(latest_haplonormal)
                    N_cliprank    = haplo_ClippingRankSum(latest_haplonormal)
                    N_likelirank  = haplo_LikelihoodRankSum(latest_haplonormal)
                    N_readposrank = haplo_ReadPosRankSum(latest_haplonormal)
                    N_mqrank      = haplo_MQRankSum(latest_haplonormal)
                    N_Hdp         = haplo_DP(latest_haplonormal)
                    N_Hmq         = haplo_MQ(latest_haplonormal)
                    
                    # Reset the current line:
                    nhaplo_line = latest_haplonormal.vcf_line
                
                else:
                    #assert genome.whoisbehind([my_vcfcall.chromosome, my_vcfcall.position], [latest_haplonormal.chromosome, latest_haplonormal.position]) == 0
                    nhaplo_line = latest_haplonormal.vcf_line
                                    
                    N_mq0 = N_mleac = N_mleaf = N_baseQrank = N_cliprank = N_likelirank = N_readposrank = N_mqrank = N_Hdp = N_Hmq = nan
            
            else:
                N_mq0 = N_mleac = N_mleaf = N_baseQrank = N_cliprank = N_likelirank = N_readposrank = N_mqrank = N_Hdp = N_Hmq = nan
            
           
           
            
            ###########################################################################################
            #################### Find the same coordinate in TUMOR vcf by SAMTOOLS ####################
            if args.samtools_tumor_vcf_file:
                
                latest_tsam_run = genome.catchup(my_coordinate, tsam_line, samT, chrom_seq)
                latest_samtumor = genome.Vcf_line(latest_tsam_run[1])
                
                # If the position exists in this samtools generated vcf file:
                if latest_tsam_run[0]:
                    assert my_vcfcall.position == latest_samtumor.position
                    
                    T_ref_for,T_ref_rev,T_alt_for,T_alt_rev = sam_info_DP4(latest_samtumor)
                    
                    #T_p_strandbias,T_p_baseQbias,T_p_mapQbias,T_p_taildisbias = sam_info_PV4(latest_samtumor)
                    
                    #try:
                        #T_Sdp  = eval( latest_samtumor.get_info_value('DP') )
                    #except TypeError:
                        #T_Sdp = nan
                    
                    #T_mq  = sam_info_MQ(latest_samtumor)
                    
                    # Reset the current line:
                    tsam_line = latest_samtumor.vcf_line
                
                # If not:
                else:
                    #assert genome.whoisbehind([my_vcfcall.chromosome, my_vcfcall.position], [latest_samtumor.chromosome, latest_samtumor.position]) == 0
                    tsam_line = latest_samtumor.vcf_line
                    
                    T_ref_for = T_ref_rev = T_alt_for = T_alt_rev = T_p_strandbias = T_p_baseQbias = T_p_mapQbias = T_p_taildisbias = T_Sdp = T_mq = nan
                    
            else:
                T_ref_for = T_ref_rev = T_alt_for = T_alt_rev = T_p_strandbias = T_p_baseQbias = T_p_mapQbias = T_p_taildisbias = T_Sdp = T_mq = nan
                
            
            


            #################### Find the same coordinate in TUMOR vcf by GATK Haplotype ####################
            # Things to extract (if available): 
            # DP, MQ, MQ0, MLEAC, MLEAF, BaseQRankSum, ClippingRankSum, LikelihoodRankSum, ReadPosRankSum, MQRankSum
            if args.haplo_tumor_vcf_file:
                latest_thaplo_run = genome.catchup(my_coordinate, thaplo_line, haploT, chrom_seq)
                latest_haplotumor = genome.Vcf_line(latest_thaplo_run[1])
                
                if latest_thaplo_run[0]:
                    assert my_vcfcall.position == latest_haplotumor.position
                    
                    # Normal haplotype caller info extraction:
                    T_mq0         = haplo_MQ0(latest_haplotumor)
                    T_mleac       = haplo_MLEAC(latest_haplotumor)
                    T_mleaf       = haplo_MLEAF(latest_haplotumor)
                    T_baseQrank   = haplo_BaseQRankSum(latest_haplotumor)
                    T_cliprank    = haplo_ClippingRankSum(latest_haplotumor)
                    T_likelirank  = haplo_LikelihoodRankSum(latest_haplotumor)
                    T_readposrank = haplo_ReadPosRankSum(latest_haplotumor)
                    T_mqrank      = haplo_MQRankSum(latest_haplotumor)
                    T_Hdp         = haplo_DP(latest_haplotumor)
                    T_Hmq         = haplo_MQ(latest_haplotumor)
                    
                    # Reset the current line:
                    thaplo_line = latest_haplotumor.vcf_line
                
                else:
                    #assert genome.whoisbehind([my_vcfcall.chromosome, my_vcfcall.position], [latest_haplotumor.chromosome, latest_haplotumor.position]) == 0
                    thaplo_line = latest_haplotumor.vcf_line
                    
                    T_mq0 = T_mleac = T_mleaf = T_baseQrank = T_cliprank = T_likelirank = T_readposrank = T_mqrank = T_Hdp = T_Hmq = nan
                    
            else:
                T_mq0 = T_mleac = T_mleaf = T_baseQrank = T_cliprank = T_likelirank = T_readposrank = T_mqrank = T_Hdp = T_Hmq = nan

            
            
            
            ############################ Find the same coordinate in NORMAL pileup ############################
            ## This is written after the SAMtools VCF because it could potentially replace them (i.e., DP4)
            if plN:
                latest_npileup_run   = genome.catchup(my_coordinate, npileup_line, plN, chrom_seq)
                latest_pileupnormal  = pileup.Pileup_line(latest_npileup_run[1])
                
                # If the position exists in the pileup file (as it should, but just in case shit happens):
                if latest_npileup_run[0]:
                    
                    assert my_vcfcall.position == latest_pileupnormal.position
                                        
                    # Normal pileup info extraction:
                    N_ref_for,N_ref_rev,N_alt_for,N_alt_rev = pileup_DP4(latest_pileupnormal, my_vcfcall.refbase, first_alt)
                    
                    # Depth of coverage including indel calls
                    #N_pdp = N_ref_for + N_ref_rev + N_alt_for + N_alt_rev
                    
                    # Reset the current line:
                    npileup_line = latest_pileupnormal.pileup_line
                    
                # If the position does not exist in this pileup:
                else:
                    npileup_line = latest_pileupnormal.pileup_line
                    N_pdp = nan
            else:
                N_pdp = nan



            ############################ Find the same coordinate in TUMOR pileup ############################
            ## This is written after the SAMtools VCF because it could potentially replace them (i.e., DP4)
            if plT:
                latest_tpileup_run   = genome.catchup(my_coordinate, tpileup_line, plT, chrom_seq)
                latest_pileuptumor   = pileup.Pileup_line(latest_tpileup_run[1])
                
                # If the position exists in the pileup file (as it should, but just in case shit happens):
                if latest_tpileup_run[0]:
                    
                    assert my_vcfcall.position == latest_pileuptumor.position
                                        
                    # Tumor pileup info extraction:
                    T_ref_for,T_ref_rev,T_alt_for,T_alt_rev = pileup_DP4(latest_pileuptumor, my_vcfcall.refbase, first_alt)
                    
                    # Depth of coverage including indel calls
                    #T_pdp = T_ref_for + T_ref_rev + T_alt_for + T_alt_rev
                    
                    # Reset the current line:
                    tpileup_line = latest_pileuptumor.pileup_line
                    
                # If the position does not exist in this pileup:
                else:
                    tpileup_line = latest_pileuptumor.pileup_line
                    T_pdp = nan
            else:
                T_pdp = nan

            
            ## If SAMtools gave no MQ (i.e., nan), uses HaplotypeCaller's MQ:
            #if math.isnan(N_mq): N_mq = N_Hmq
            
            ## If HaplotypeCaller does not give MQ either, uses VarDict's.
            #if math.isnan(N_mq): N_mq = N_mq_vd
            ## And if VarDict is also nan, then let it be.
            ## Beware that SAMtool is processed first with N/T_mq, so if it's a real number it'll take precedence. 
            
            ## Same for Tumor:
            #if math.isnan(T_mq): T_mq = T_Hmq
            #if math.isnan(T_mq): T_mq = T_mq_vd
            
            
            ## Pileup depth takes precedence, followed by SAMtools, followed by pileup
            #if not math.isnan(N_pdp):
                #N_dp = N_pdp
            #elif not math.isnan(N_Hdp):
                #N_dp = N_Hdp
            #else:
                #N_dp = nan
            
            #if not math.isnan(T_pdp):
                #T_dp = T_pdp
            #elif not math.isnan(T_Hdp):
                #T_dp = T_Hdp
            #else:
                #T_dp = nan
            
            
            ###
            out_line = out_header.format( \
            CHROM                   = my_vcfcall.chromosome,                                  \
            POS                     = my_vcfcall.position,                                    \
            ID                      = my_vcfcall.identifier,                                  \
            REF                     = my_vcfcall.refbase,                                     \
            ALT                     = my_vcfcall.altbase,                                     \
            if_MuTect               = cga_positive,                                           \
            if_VarScan2             = varscan2_positive,                                      \
            if_JointSNVMix2         = jointsnvmix2_positive,                                  \
            if_SomaticSniper        = somaticsniper_positive,                                 \
            if_VarDict              = vardict_positive,                                       \
            MuSE_Tier               = muse_tier,                                              \
            VarScan2_Score          = rescale(score_varscan2,      'phred', p_scale, 1001),   \
            SNVMix2_Score           = rescale(score_jointsnvmix2,  'phred', p_scale, 1001),   \
            Sniper_Score            = rescale(score_somaticsniper, 'phred', p_scale, 1001),   \
            VarDict_Score           = rescale(score_vardict,       'phred', p_scale, 1001),   \
            if_dbsnp                = in_dbsnp,                                               \
            COMMON                  = score_common_snp,                                       \
            N_DP                    = N_dp,                                                   \
            N_NM                    = n_nm,                                                   \
            N_PMEAN                 = n_pmean,                                                \
            N_QSTD                  = n_qstd,                                                 \
            N_PSTD                  = n_pstd,                                                 \
            N_VQUAL                 = n_vqual,                                                \
#           N_StrandBias            = rescale(N_p_strandbias,  'fraction', p_scale, 1001),    \
#           N_BaseQBias             = rescale(N_p_baseQbias,   'fraction', p_scale, 1001),    \
#           N_MapQBias              = rescale(N_p_mapQbias,    'fraction', p_scale, 1001),    \
#           N_TailDistBias          = rescale(N_p_taildisbias, 'fraction', p_scale, 1001),    \
            N_MLEAC                 = N_mleac,                                                \
            N_MLEAF                 = N_mleaf,                                                \
            N_BaseQRankSum          = N_baseQrank,                                            \
            N_ClippingRankSum       = N_cliprank,                                             \
            N_LikelihoodRankSum     = N_likelirank,                                           \
            N_ReadPosRankSum        = N_readposrank,                                          \
            N_MQRankSum             = N_mqrank,                                               \
            nBAM_REF_MQ             = '%g' % n_ref_mq,                                        \
            nBAM_ALT_MQ             = '%g' % n_alt_mq,                                        \
            nBAM_Z_Ranksums_MQ      = '%g' % n_z_ranksums_mq,                                 \
            nBAM_REF_BQ             = '%g' % n_ref_bq,                                        \
            nBAM_ALT_BQ             = '%g' % n_alt_bq,                                        \
            nBAM_Z_Ranksums_BQ      = '%g' % n_z_ranksums_bq,                                 \
            nBAM_REF_NM             = '%g' % n_ref_NM,                                        \
            nBAM_ALT_NM             = '%g' % n_alt_NM,                                        \
            nBAM_REF_Concordant     = n_ref_concordant_reads,                                 \
            nBAM_REF_Discordant     = n_ref_discordant_reads,                                 \
            nBAM_ALT_Concordant     = n_alt_concordant_reads,                                 \
            nBAM_ALT_Discordant     = n_alt_discordant_reads,                                 \
            nBAM_Concordance_FET    = rescale(n_concordance_fet, 'fraction', p_scale, 1001),  \
            N_REF_FOR               = n_ref_for,                                              \
            N_REF_REV               = n_ref_rev,                                              \
            N_ALT_FOR               = n_alt_for,                                              \
            N_ALT_REV               = n_alt_rev,                                              \
            nBAM_StrandBias_FET     = rescale(n_strandbias_fet, 'fraction', p_scale, 1001),   \
            nBAM_Z_Ranksums_EndPos  = '%g' % n_z_ranksums_endpos,                             \
            nBAM_REF_Clipped_Reads  = n_ref_SC_reads,                                         \
            nBAM_ALT_Clipped_Reads  = n_alt_SC_reads,                                         \
            nBAM_Clipping_FET       = rescale(n_clipping_fet, 'fraction', p_scale, 1001),     \
            nBAM_REF_MQ0            = n_ref_MQ0,                                              \
            nBAM_ALT_MQ0            = n_alt_MQ0,                                              \
            nBAM_Other_Reads        = n_noise_read_count,                                     \
            nBAM_REF_InDel_3bp      = n_ref_indel_3bp,                                        \
            nBAM_REF_InDel_2bp      = n_ref_indel_2bp,                                        \
            nBAM_REF_InDel_1bp      = n_ref_indel_1bp,                                        \
            nBAM_ALT_InDel_3bp      = n_alt_indel_3bp,                                        \
            nBAM_ALT_InDel_2bp      = n_alt_indel_2bp,                                        \
            nBAM_ALT_InDel_1bp      = n_alt_indel_1bp,                                        \
            SOR                     = sor,                                                    \
            MSI                     = msi,                                                    \
            MSILEN                  = msilen,                                                 \
            SHIFT3                  = shift3,                                                 \
            MaxHomopolymer_Length   = homopolymer_length,                                     \
            SiteHomopolymer_Length  = site_homopolymer_length,                                \
            T_DP                    = T_dp,                                                   \
            T_NM                    = t_nm,                                                   \
            T_PMEAN                 = t_pmean,                                                \
            T_QSTD                  = t_qstd,                                                 \
            T_PSTD                  = t_pstd,                                                 \
            T_VQUAL                 = t_vqual,                                                \
#           T_StrandBias            = rescale(T_p_strandbias,  'fraction', p_scale, 1001),    \
#           T_BaseQBias             = rescale(T_p_baseQbias,   'fraction', p_scale, 1001),    \
#           T_MapQBias              = rescale(T_p_mapQbias,    'fraction', p_scale, 1001),    \
#           T_TailDistBias          = rescale(T_p_taildisbias, 'fraction', p_scale, 1001),    \
            T_MLEAC                 = T_mleac,                                                \
            T_MLEAF                 = T_mleaf,                                                \
            T_BaseQRankSum          = T_baseQrank,                                            \
            T_ClippingRankSum       = T_cliprank,                                             \
            T_LikelihoodRankSum     = T_likelirank,                                           \
            T_ReadPosRankSum        = T_readposrank,                                          \
            T_MQRankSum             = T_mqrank,                                               \
            tBAM_REF_MQ             = '%g' % t_ref_mq,                                        \
            tBAM_ALT_MQ             = '%g' % t_alt_mq,                                        \
            tBAM_Z_Ranksums_MQ      = '%g' % t_z_ranksums_mq,                                 \
            tBAM_REF_BQ             = '%g' % t_ref_bq,                                        \
            tBAM_ALT_BQ             = '%g' % t_alt_bq,                                        \
            tBAM_Z_Ranksums_BQ      = '%g' % t_z_ranksums_bq,                                 \
            tBAM_REF_NM             = '%g' % t_ref_NM,                                        \
            tBAM_ALT_NM             = '%g' % t_alt_NM,                                        \
            tBAM_REF_Concordant     = t_ref_concordant_reads,                                 \
            tBAM_REF_Discordant     = t_ref_discordant_reads,                                 \
            tBAM_ALT_Concordant     = t_alt_concordant_reads,                                 \
            tBAM_ALT_Discordant     = t_alt_discordant_reads,                                 \
            tBAM_Concordance_FET    = rescale(t_concordance_fet, 'fraction', p_scale, 1001),  \
            T_REF_FOR               = t_ref_for,                                              \
            T_REF_REV               = t_ref_rev,                                              \
            T_ALT_FOR               = t_alt_for,                                              \
            T_ALT_REV               = t_alt_rev,                                              \
            tBAM_StrandBias_FET     = rescale(t_strandbias_fet, 'fraction', p_scale, 1001),   \
            tBAM_Z_Ranksums_EndPos  = '%g' % t_z_ranksums_endpos,                             \
            tBAM_REF_Clipped_Reads  = t_ref_SC_reads,                                         \
            tBAM_ALT_Clipped_Reads  = t_alt_SC_reads,                                         \
            tBAM_Clipping_FET       = rescale(t_clipping_fet, 'fraction', p_scale, 1001),     \
            tBAM_REF_MQ0            = t_ref_MQ0,                                              \
            tBAM_ALT_MQ0            = t_alt_MQ0,                                              \
            tBAM_Other_Reads        = t_noise_read_count,                                     \
            tBAM_REF_InDel_3bp      = t_ref_indel_3bp,                                        \
            tBAM_REF_InDel_2bp      = t_ref_indel_2bp,                                        \
            tBAM_REF_InDel_1bp      = t_ref_indel_1bp,                                        \
            tBAM_ALT_InDel_3bp      = t_alt_indel_3bp,                                        \
            tBAM_ALT_InDel_2bp      = t_alt_indel_2bp,                                        \
            tBAM_ALT_InDel_1bp      = t_alt_indel_1bp,                                        \
            InDel_Length            = indel_length,                                           \
            TrueVariant_or_False    = judgement )
            
            # Print it out to stdout:
            outhandle.write(out_line + '\n')
            
        
        # Read on:
        my_line = my_vcf.readline().rstrip()



## Close BAM files if they're opened. 
#if args.tumor_bam_file:
    #tbam.close()
    
#if args.normal_bam_file:
    #nbam.close()
